{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-03-14T00:04:07.577834+00:00",
  "repo": "ietf-wg-add/draft-ietf-add-ddr",
  "labels": [
    {
      "name": "design",
      "description": "",
      "color": "1d76db"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "41d366"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "out of scope",
      "description": "Out of scope of the WG Charter",
      "color": "e99695"
    },
    {
      "name": "parked",
      "description": "Recorded but not being worked on",
      "color": "f9d0c4"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU4MTAyOTI2MDU=",
      "title": "Clarify behavior with lack of v4/v6 hints",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/2",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [
        "mstojens"
      ],
      "labels": [],
      "body": "From Eliot Lear:\r\n\r\nThe draft currently reads:\r\n\r\n When responding to these special queries for\r\n   \"dns://resolver.arpa\", the SVCB records SHOULD contain at least one\r\n   \"ipv4hint\" and/or \"ipv6hint\" keys. \r\n\r\nWhat happens when neither hint is present?  The client should just query the local infrastructure, right?  You almost say that, but not quite.",
      "createdAt": "2021-02-17T15:36:08Z",
      "updatedAt": "2021-02-23T17:50:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is an interesting case. There are threat model implications to always querying the template name elsewhere. \r\n\r\nI will draft up something to address that includes a commentary on the implications for the client.",
          "createdAt": "2021-02-23T17:50:23Z",
          "updatedAt": "2021-02-23T17:50:23Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU4MTAyOTMwMTE=",
      "title": "DDR section 4.1",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/3",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [
        "mstojens"
      ],
      "labels": [],
      "body": "From Eliot Lear:\r\n\r\nCan you explain the following statement?\r\n\r\nand that IP address is a private address\r\n   (such as those defined in [RFC1918]\r\n\r\nI ask because it appears that you are using private addresses as some sort of security property.  I recommend against that, not least of which is that end systems that are likely to deploy this stuff will have a wide ranging mishmosh of addressing plans, and of course, private network addresses don\u2019t really have any positive security properties to speak of.\r\n\r\nThe only aspect I can see is that one really has to be quite careful of including private network addresses in certificates.  Of course, public trust anchors won\u2019t allow it, but even private ones will have some difficulty.  Your average bank might have multiple overlapping zones of trust - it\u2019s a pretty hairy scene.\r\n",
      "createdAt": "2021-02-17T15:36:34Z",
      "updatedAt": "2021-02-23T17:59:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intent of that section is to say that \"if you were going to send this local IP address unencrypted traffic anyway, using encryption to that same IP address is a net improvement to the threat model.\" It certainly was not meant to imply that private addresses could be verified via the TLS cert SAN mechanism used for public addresses.\r\n\r\nI can try to rephrase this section to be more accurate. Please comment again if I missed the point.",
          "createdAt": "2021-02-23T17:59:00Z",
          "updatedAt": "2021-02-23T17:59:00Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU4MTM4Nzk1NTg=",
      "title": "Reference threat model",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/4",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Copied conversation below from https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/143",
      "createdAt": "2021-02-22T21:29:27Z",
      "updatedAt": "2021-02-22T21:32:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nA. Security design\r\n\r\n> \"In order to be considered an authenticated Equivalent Encrypted Resolver, the TLS certificate presented by the Encrypted Resolver MUST contain both the domain name (from the SVCB answer) and the IP address of its equivalent Unencrypted Resolver\"\r\n\r\nRequiring the certificate to cover the TargetName is unusual. Why does it help for the certificate to contain this domain name, if it is also required to authenticate or match the DNS server IP? Is a nontrivial TargetName always required?\r\n\r\n> \"An attacker might try to direct Encrypted DNS traffic to itself by causing the client to think that a discovered Equivalent Encrypted Resolver uses a different IP address from the Unencrypted Resolver.\"\r\n\r\nIt seems like you are contemplating an attacker who controls the DNS path but not the RA/DHCP path. I'd appreciate seeing a few more words on that beyond the current reference to RA protection.\r\n\r\nIn general, some text on threat modeling might help to justify the design decisions.",
          "createdAt": "2021-02-22T21:30:22Z",
          "updatedAt": "2021-02-22T21:30:22Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nPartly, I\u2019m imagining we can rely on or take some of the threat modeling text from the requirements document here. However, I agree that that should be referenced or included.",
          "createdAt": "2021-02-22T21:30:39Z",
          "updatedAt": "2021-02-22T21:30:39Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## martinthomson said...\r\n\r\nI think that for equivalence, it is sufficient to include just the ipAddress SAN. Clients have to have a single target identity to match, or it gets a little tricky.\r\n\r\nThis assumes that the provenance of the IP is somehow not subject to attack. This includes DHCP/RA, manual configuration, and other forms of configuration like enterprise policy systems.\r\n\r\nBut it's not really that. This isn't about establishing whether the IP address is the right one, it's about saying affirmatively that this is the same as this other thing. For that, you don't need to worry about where the IP address came from. Of course, this is a stronger assertion regarding the DoT/DoH server than you can make about the Do53 server. The former is authenticated; the latter relies on the integrity of the route.",
          "createdAt": "2021-02-22T21:31:24Z",
          "updatedAt": "2021-02-22T21:31:24Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## vparla said...\r\n\r\nOne question I have is the embedding of IP addresses in certificates at all. In a world of migrating workloads on generic compute, it is not unreasonable to expect that DoH servers might not occupy a fixed IP address necessarily. While it can be accomplished with Anycast addressing, NATing or Loadbalancing schemes, I still have some reservations about the construct in general. Maybe I am missing something obvious here.",
          "createdAt": "2021-02-22T21:31:40Z",
          "updatedAt": "2021-02-22T21:31:52Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## bemasc issued a PR\r\n\r\nhttps://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/pull/147",
          "createdAt": "2021-02-22T21:32:41Z",
          "updatedAt": "2021-02-22T21:32:41Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU4MTM4ODMxMTk=",
      "title": "Clarify use of address hints",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/5",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Migrated from original DEER issue: https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/145",
      "createdAt": "2021-02-22T21:34:45Z",
      "updatedAt": "2021-02-22T21:35:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nFrom Ben:\r\n\r\n> \"These address hints ... avoid additional DNS lookup for the A and AAAA records of the Encrypted Resolver name.\"\r\n\r\nStrictly speaking, a compliant SVCB client is expected to perform the additional lookups anyway. The hints just avoid a delay while those queries complete. If you think it's important to \"skip\" those followup queries, we would have to make a deeper change. Otherwise, you could say \"avoid waiting for DNS lookup...\".",
          "createdAt": "2021-02-22T21:35:14Z",
          "updatedAt": "2021-02-22T21:35:14Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU4MTM4ODQxNTQ=",
      "title": "DEER caching text",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/6",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Migrated from original DEER issue: https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/155",
      "createdAt": "2021-02-22T21:36:23Z",
      "updatedAt": "2021-02-22T21:36:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## bemasc said...\r\n\r\nThe text says\r\n\r\n> If a caching forwarder consults multiple resolvers, it may be possible for it to cache records for the \"resolver.arpa\" Special Use Domain Name (SUDN) for multiple resolvers.\r\n\r\nThis is not true of any reasonable forwarder. RRsets are atomic collections, and cannot be mixed from multiple sources. Doing so would entirely break DNSSEC, for example. Unless you know of a forwarder that exhibits this seriously broken behavior, I don't think it bears mentioning.",
          "createdAt": "2021-02-22T21:36:56Z",
          "updatedAt": "2021-02-22T21:36:56Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU4MTM4ODYwODE=",
      "title": "Clarification of SUDN",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/7",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mstojens"
      ],
      "labels": [],
      "body": "Migrated from original DEER issue: https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/160",
      "createdAt": "2021-02-22T21:38:23Z",
      "updatedAt": "2021-02-22T21:40:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## awfulhak said...\r\n\r\nThe Special Use Domain Name (SUDN) resolver.arpa needs more clarification. Specifically:\r\n\r\n- Queries against the .arpa nameservers\r\n  The draft should mention that .arpa is a delegated zone, currently served by the root nameservers. Clients that query a resolver that is unaware of this requirement will \"leak\" queries to the root nameservers.\r\n- When _dns.resolver.arpa/SVCB is not present in a resolver configuration\r\n  Section 6.1 discusses how a forwarder should behave and suggests that results should not be cached other than for Equivalent Encrypted Resolvers under their control. How is that determined?\r\n  There is no discussion around a non-forwarding resolver's behaviour. Should it return NODATA?\r\n  Forwarding queries to _dns.resolver.arpa/SVCB will attempt to attach a client to an upstream resource's equivalent resolver. If that equivalent resolver's cert doesn't include the forwarder, the client must reject the answer. Is it not therefore the case that the forwarder caching behaviour is irrelevant? All valid responses to this query must be equivalent to the forwarder itself.\r\n- When _dns.resolver.arpa/SVCB is present in a resolver configuration\r\n  I would suggest some clarification wording something like this: The expectation is that this record set will detail equivalent resolvers. A client that chooses not to interact with any of these equivalent resolvers SHOULD continue to use the unencrypted resolver, honouring the SVCB TTL. When the SVCB TTL expires, the client may choose to re-query in an attempt to discover newly available equivalents.\r\n\r\nI would suggest (prefer?) changing the SUDN behaviour so that queries against it are never sent upstream. Resolvers (and forwarders) that do not have a configured _dns.resolver.arpa/SVCB RRset should return NODATA. This would mean that resolver.arpa SUDN RRsets are always specific to the IP queried.",
          "createdAt": "2021-02-22T21:40:06Z",
          "updatedAt": "2021-02-22T21:40:06Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nIt may be good to model the advice after RFC8880, which defines ipv4only.arpa.",
          "createdAt": "2021-02-22T21:40:33Z",
          "updatedAt": "2021-02-22T21:40:33Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU4MTM4ODgzOTk=",
      "title": "Clarification of expectations in certain NAT environments",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/8",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue migrated from DEER repo: https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/161",
      "createdAt": "2021-02-22T21:42:15Z",
      "updatedAt": "2021-02-22T21:44:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## vparla said...\r\n\r\nIt would be helpful if there was a paragraph that described what the expected behavior is in certain NAT scenarios.\r\n\r\nSince the IP address must be embedded in the TLS certificate, certain NAT scenarios could present a problem for this approach.\r\n\r\nFor example, if the assigned DNS IP addresses via DHCP are not the actual IP address(es) associated with the DNS service, there could be an issue. How would such a deployment scenario be addressed?",
          "createdAt": "2021-02-22T21:42:29Z",
          "updatedAt": "2021-02-22T21:42:29Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nCertainly worth a paragraph or note.\r\n\r\n@vparla can you clarify exactly which NAT scenarios you're considering here? If the client is behind a NAT reaching out to a DNS resolver that is not behind the NAT, the client presumably is reaching out to the \"real\" IP address of the resolver. If the resolver is behind the NAT with the client, then that seems to be a case in which we'd expect it to simply have the same address as the unencrypted resolver?",
          "createdAt": "2021-02-22T21:42:48Z",
          "updatedAt": "2021-02-22T21:42:48Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## vparla said...\r\n\r\n@tfpauly.\r\nSo if the DHCP assigned DNS address(es) are NAT addresses instead of the actual DNS server addresses, what is the expected outcome? It was unclear to me if this would work correctly as the client would see the NAT'd address(es) via DHCP and the certificate would hold the actual address(es), not the NAT'd address seen via DHCP.\r\n\r\nSo imagine NAT assigned address is 1.2.3.4 and actual address of DNS server is 4.5.6.7. What would be the expected outcome here? DNS from the client would got to 1.2.3.4:53 then be NAT'd to actual DNS server @ 4.5.6.7:53\r\n\r\nNote this is an edge case for the most part, but possible.",
          "createdAt": "2021-02-22T21:43:10Z",
          "updatedAt": "2021-02-22T21:43:10Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## bemasc said...\r\n\r\n@vparla It sounds like you're describing a classic \"DNS forwarder\". I don't think this matches typical usage of \"NAT\", which does not modify the server IP as observed by the client.",
          "createdAt": "2021-02-22T21:43:25Z",
          "updatedAt": "2021-02-22T21:43:25Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## vparla said...\r\n\r\nFor the sake of this discussion, a DNS forwarder and a NAT can be viewed as roughly equivalent for this problem.\r\nClient assigned DNS server address is 1.2.3.4 and as such sends DNS to 1.2.3.4:53. The actual DNS Server is 4.5.6.7 and the IP in the certificate are also 4.5.6.7",
          "createdAt": "2021-02-22T21:43:43Z",
          "updatedAt": "2021-02-22T21:43:43Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## bemasc said...\r\n\r\nThis situation would not occur when using \"NAT\" according to the definition that I'm used to, but it is an important scenario to consider.\r\n\r\nThe current draft essentially rules this \"out of scope\". As you observed, the upgrade will not occur in this configuration.\r\n\r\nI have posted a (rather invasive) PR that would put this in-scope, with various safeguards to prevent unauthorized redirection: #147.",
          "createdAt": "2021-02-22T21:44:01Z",
          "updatedAt": "2021-02-22T21:44:01Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## vparla said...\r\n\r\nI am happy with it just being clearly articulated in terms of the scenario and the outcome.\r\nthanks for looking at it.",
          "createdAt": "2021-02-22T21:44:16Z",
          "updatedAt": "2021-02-22T21:44:16Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU4MTM4OTAzNTk=",
      "title": "Clarification on Opportunistic with respect to dns://resolver.arpa",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/9",
      "state": "OPEN",
      "author": "mstojens",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue migrated from DEER repo: https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/issues/163",
      "createdAt": "2021-02-22T21:45:27Z",
      "updatedAt": "2021-02-22T21:45:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## magicalo said...\r\n\r\nCan you clarify why dns://resolver.arpa would matter in an Opportunistic scenario, or at least in a subset of Opportunistic options.\r\n\r\nCouldn't a DNS client simply attempt DoH on the same IP address(es) as Do53 (ideally in parallel)\r\nand if the certificate returned during the DoH exchanges meets the criteria (matching IPs listed in the SAN, cert validation, etc.) then it would simply attempt the upgrade, never having to consider/engage dns://resolver.arpa\r\n\r\nMaybe I have misunderstood this section or the role dns://resolver.arpa would play here. Could you clarify please.",
          "createdAt": "2021-02-22T21:45:42Z",
          "updatedAt": "2021-02-22T21:45:42Z"
        },
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## tfpauly said...\r\n\r\nThe purpose of the SVCB record information in the \"opportunistic\" scenario is getting extra metadata about the resolvers. This is particularly important or useful for DoH, where the URI path and HTTP authority would not otherwise be known. The client could guess, but it may not be able to form a valid HTTP request.\r\n\r\nThe DoT ports, etc, could also be different, but that's often less useful.",
          "createdAt": "2021-02-22T21:45:56Z",
          "updatedAt": "2021-02-22T21:45:56Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU4MjYxMTA0ODU=",
      "title": "minor: provide ipv6hint in examples",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/issues/10",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We should make sure that any examples including an ipv4hint\r\nalso include an ipv6hint or only include an ipv6hint.\r\n\r\n(per https://www.iab.org/2016/11/07/iab-statement-on-ipv6/)",
      "createdAt": "2021-03-09T15:31:34Z",
      "updatedAt": "2021-03-09T15:31:34Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyNjYyMzg1",
      "title": "Update draft-ietf-add-ddr.md",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/pull/1",
      "state": "MERGED",
      "author": "pdadair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changed 2 instances of DEER to DDR",
      "createdAt": "2021-02-12T17:21:29Z",
      "updatedAt": "2021-02-12T17:24:53Z",
      "baseRepository": "ietf-wg-add/draft-ietf-add-ddr",
      "baseRefName": "main",
      "baseRefOid": "7a0ced90e57958d3612ea0bb6b68700e3d4d79f1",
      "headRepository": "pdadair/draft-ietf-add-ddr",
      "headRefName": "patch-1",
      "headRefOid": "3b28e0503e35f392bdbd62496694c5a707354a87",
      "closedAt": "2021-02-12T17:24:53Z",
      "mergedAt": "2021-02-12T17:24:53Z",
      "mergedBy": "mstojens",
      "mergeCommit": {
        "oid": "e09202cfa2049f2a664e2404a5a2edcccb3441da"
      },
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was so focused on finding \"equivalent\" that I missed a couple deer apparently. Thank you!",
          "createdAt": "2021-02-12T17:24:19Z",
          "updatedAt": "2021-02-12T17:24:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg4NjAwODk3",
      "title": "Proposal: Enable secure cross-IP upgrade",
      "url": "https://github.com/ietf-wg-add/draft-ietf-add-ddr/pull/11",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This proposal adjusts various aspects of the security model to enable secure upgrade from traditional local DNS forwarding equipment.\r\n\r\nIncludes CNAME idea borrowed from https://tools.ietf.org/html/draft-rescorla-doh-cdisco-00\r\n\r\nSee https://github.com/tfpauly/draft-pauly-adaptive-dns-privacy/pull/147 for the original version and comments.",
      "createdAt": "2021-03-09T20:48:29Z",
      "updatedAt": "2021-03-11T15:36:06Z",
      "baseRepository": "ietf-wg-add/draft-ietf-add-ddr",
      "baseRefName": "main",
      "baseRefOid": "ca3ed153f4bf3b083746d23e97b34b889eb86167",
      "headRepository": "bemasc/draft-ietf-add-ddr",
      "headRefName": "bemasc-local-upgrade",
      "headRefOid": "fdb38f5fbf2a08eea8a3ad1ec3e16b00d4aa4eba",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mstojens",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have concerns about the impact of an attack against the recursive resolver. We have focused on the attacker who has access to the local network hijacking the upgrade process. Let's say instead the attacker is interested in hijacking the traffic for all the clients of the upstream resolver instead.\r\n\r\nDDR as currently written: the attacker places a malicious SVCB record in the upstream resolver (x.y.z.w) referring to doh.attacker.example. The attack must also be able to present a valid certificate claiming ownership of x.y.z.w or else the client will reject the upgrade.\r\n\r\nDDR with this PR: the attacker places a malicious CNAME record in the  upstream resolver (x.y.z.w) referring to doh.attacker.example. The attacker needs to do nothing else in order to harvest all of the DNS traffic for all clients of the x.y.z.w resolver for as long as the malicious CNAME record goes unnoticed. \r\n\r\nThe difficulty of the attack is notable, but is far lower than it is without this PR, and has a far larger impact than simple one local network as the transient attacker scenario we have been discussing.\r\n\r\nWhile it's true that this attack could be arguably the same as simply taking full control of the recursive resolver, the difference is that the client will think the connection is more secure than simply sending plain-text queries, which will not be true at a bar lower than \"taking control of a TLS identity\". That also requires a persistent attack (control of the resolver) versus a transient attack (add a single malicious CNAME entry).\r\n\r\nIn light of the threat model requests being made during the meeting: is this an attack we want to consider or acknowledge?",
          "createdAt": "2021-03-11T15:36:06Z",
          "updatedAt": "2021-03-11T15:36:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODAwMjIz",
          "commit": {
            "abbreviatedOid": "83cf989"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T14:51:51Z",
          "updatedAt": "2021-03-10T15:20:42Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "This seems overly prescriptive.  A recommendation to ues 5min is fine, but a requirement is too strong for me.  A device with a long history of successful use of that address might be willing to tolerate longer.",
              "createdAt": "2021-03-10T14:51:51Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 59,
              "body": "Would SVCB AliasMode record be an acceptable substitute for this?",
              "createdAt": "2021-03-10T14:52:45Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nprevent this kind of discovery can intercept queries to `_dns.resolver.arpa`.\r\n```\r\nNot a constraint on behaviour that affects others.",
              "createdAt": "2021-03-10T14:55:01Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nSince clients can receive DNS SVCB answers over unencrypted DNS, on-path\r\n```",
              "createdAt": "2021-03-10T14:59:18Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 128,
              "body": "Does this mean that a DNSSEC signed record at _dns.$HOSTNAME is a pin in some circumstances?  That is, for the duration of its TTL, if the server is not available, clients might not be able to access DNS service.",
              "createdAt": "2021-03-10T15:01:29Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 4,
              "body": "This needs a strong definition for \"public range\", citing the v6 addressing architecture or whatever else applies.",
              "createdAt": "2021-03-10T15:02:50Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5MzMyNjkx",
          "commit": {
            "abbreviatedOid": "83cf989"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T01:57:16Z",
          "updatedAt": "2021-03-11T02:04:18Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done",
              "createdAt": "2021-03-11T01:57:16Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 42,
              "body": "OK.  I'm not sure what rule we're aiming for here, but I've adjusted all the normativity so that MUST-level requirements are only used where needed for compatibility, or for security if the harm is to another party.",
              "createdAt": "2021-03-11T01:58:35Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 59,
              "body": "Sort of.  AliasMode records would work but\r\n1. They wouldn't be any better.\r\n2. They would be slower to fetch on existing resolvers.\r\n3. They would break the partial getaddrinfo compatibility.\r\n\r\nThat seemed like a good enough reason to mandate CNAME.",
              "createdAt": "2021-03-11T02:00:25Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            },
            {
              "originalPosition": 128,
              "body": "As [currently specified](https://datatracker.ietf.org/doc/html/draft-schwartz-svcb-dns-02#section-9.2), it's a pin even if not DNSSEC signed.  The theory here is that, even without DNSSEC, you could easily have an adversary who can block your DoT connection but not your bootstrap queries.  You wouldn't want that adversary to cause an automatic fallback to plaintext DNS.",
              "createdAt": "2021-03-11T02:03:57Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5MzQ2Njky",
          "commit": {
            "abbreviatedOid": "9c2d542"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T02:31:38Z",
          "updatedAt": "2021-03-11T02:31:39Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think that you are right about the use of MUST.  What I wanted to highlight here was that a specific maximum here needs to be better supported to be strictly mandatory.",
              "createdAt": "2021-03-11T02:31:39Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NzU2NTgw",
          "commit": {
            "abbreviatedOid": "9c2d542"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T13:26:57Z",
          "updatedAt": "2021-03-11T13:26:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "What if there is a network outage where packets are dropped? I'm concerned that there could be a transient state, unlucky or induced by an attacker flooding the network, where the client ends up being downgraded after previously having been secure.",
              "createdAt": "2021-03-11T13:26:57Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5ODQ5NDQ3",
          "commit": {
            "abbreviatedOid": "e3cf04e"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T14:53:40Z",
          "updatedAt": "2021-03-11T14:53:41Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "This is a general concern in either mode.  I've clarified that the discovery process blocks other queries.  Note that this makes the draft sharply incompatible with (hypothetical, horribly broken) SVCB blackhole resolvers.  I'm fine with that.  (Implementers can add an escape hatch if it proves necessary.)\r\n\r\nI also added an exemption under \"Optimizations\" for the case where the client happens to recognize and trust the discovered Encrypted Resolver.",
              "createdAt": "2021-03-11T14:53:41Z",
              "updatedAt": "2021-03-11T14:58:57Z"
            }
          ]
        }
      ]
    }
  ]
}